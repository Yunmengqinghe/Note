## 一、构造函数和析构函数
1. 构造函数和析构函数会被编译器自动调用，完成对象初始化和清理工作。如果我们不提供构造和析构，编译器会提供构造函数和析构函数的空实现。
2. 函数的实现
	+ 构造函数：主要作用在于**创建对象**时为对象的成员属性赋值，构造函数由编译器自动调用，无需手动调用
	+ 析构函数：主要作用于**对象销毁**，系统自动调用，执行一些清理工作
3. 构造函数
	+ 语法：`类名(){}`
	+ 可以有参，可以重载
	+ 无需手动调用
4. 析构函数
	+ 语法：`~类名(){}`
	+ 不能有参，不能重载
	+ 无需手动调用

## 二、构造函数的分类及调用
1. 两种分类方式
	+ 按照参数：有参构造和无参构造
	+ 按照类型：普通构造和拷贝构造
2. 调用方式
	**括号法**、显示法、隐式转换法
```Cpp
//拷贝构造
class Person {
public:
	Person(const Person& p)
	{
		age = p.Getage();
	}
	int Getage()
	{
		return age;
	}
private:
	int age;
};

//注意事项
//不要用拷贝构造函数初始化匿名对象Person(p)，编译器会认为
Person (p) = Person p;
//导致重复定义
```

## 三、构造函数调用规则
1. 创建一个类，C++编译器会给每个类都添加至少3个函数：
	+ 默认构造(空实现)
	+ 析构函数(空实现)
	+ 拷贝构造(值拷贝)
2. 规则
	+ 如果用户自定义有参构造函数，Cpp不在提供默认无参构造，但是会提供默认拷贝构造
	+ 如果用户定义拷贝构造函数，Cpp不会提供其他构造函数

## 四、深拷贝和浅拷贝
1. 拷贝类型：
	+ 浅拷贝：简单的赋值拷贝操作
	+ 深拷贝：在堆区重新申请空间，进行拷贝操作
```Cpp
class Person
{
public:
	Person(int age, int hight)
	{
		this->age = age;
		
		//在堆区开辟空间进行深拷贝
		//new 返回指针(内存地址)
		this->hight = new int(hight);
	}
	~Person()
	{
		//开辟在堆里的数据要手动释放
		if(hight != NULL)
		{
			delete hight;
			hight = NULL;
		}
	}

private:
	int age;
	int* hight;
};
```

2. 浅拷贝的问题：会造成堆区内存的重复释放
![[Pasted image 20230807005715.png]]
+ 解决方法
```Cpp
//自己手写拷贝构造实现深拷贝
Person(const Person& p)
{
	age = p._age;
	hight = new int(*p._hight);
}

```

3. 总结
如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

## 五、初始化列表
1. 作用：Cpp初始化属性的语法
2. 语法：`构造函数(): 属性1(值1), 属性2(值2)...`
```Cpp
Person(int a, int b, int c): _a(a), _b(b), _c(c)
{

}
```

## 六、类对象作为类成员
1. 构造顺序
	当本类中有其他类的对象时，先构造其他类对象，再构造自身
2. 析构顺序(与构造顺序相反)
	当本类中有其他类的对象时，先析构自身，再析构其他类对象

## 七、静态成员(static)
+ 静态成员分类
	1. 静态成员变量
		+ 所有对象共享同一份数据
		+ 在编译阶段分配内存
		+ 类内声明，类外初始化
		+ 在头文件内为静态成员变量赋值，会导致多个对象文件中存在同名的静态成员变量，引发重定义错误
	2. 静态成员函数
		+ 所有对象共享同一个函数
		+ 静态成员函数只能访问静态成员变量 
```Cpp
//类内声明，类外初始化
//Person.h
class Person
{
public:
	static int a;

	static void func()
	{
		//只能访问静态成员变量
		a = 1;
		cout << a << endl;
	}
};

//Person.cpp
int Person::a = 100;
```

+ 静态成员(函数)访问
	+ 通过对象访问
	+ 通过类名访问
```Cpp
int main()
{
	//通过对象
	Person p;
	cout << p.a << endl;
	p.func();

	//通过类名
	cout << Person::a << endl;
	Person::func();
}
```