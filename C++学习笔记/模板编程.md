## 一、模板概念
1. 模板就是建立通用的磨具，大大提高复用性
2. 模板并不可以直接使用，他只是一个框架

## 二、函数模板
### 函数模板语法
1. 作用：建立一个通用函数，其函数返回值和形参类型可以不具体制定，用一个虚拟的类型来代表
2. 语法
```cpp
template<typename T>
//函数声明或定义

//template 声明创建函数模板
//typename 表明其后面的符号是一种数据类型，可以用class代替
//T 通用的数据类型，名称可以替换，通常为大写

//使用函数模板时候可以自己指定类型
```

### 函数模板注意事项
1. 注意事项
	+ 自动类型推导，必须要数据类型相同T才相同，才可以使用
	+ 函数模板要确定出T的数据类型，才可以使用
```cpp
template<class T>
void Func()
{
	cout << "Using" << endl;
}

int main()
{
	Func<int>();
}
```

### 普通函数与函数模板的区别
1. 普通函数与函数模板区别
	+ 普通函数调用时可以发生自动类型转换（隐式类型转换）
	+ 函数模板调用时，如果利用自动类型推导，不回发生隐式类型转换
	+ 如果利用显式指定类型的方式，可以发生隐式类型转换
```cpp
//普通函数
int IntAdd(int a, int b)
{
	return a + b;
}

int main()
{
	int a = 1;
	char ch = 'A';
	//ch被转换成了int类型的值
	cout << IntAdd(a, ch) << endl;
}

//模板
template <class T>
T TAdd(T a, T b)
{
	return a + b;
}

int main()
{
	int a = 1;
	char ch = 'A';
	//显式指定类型会转换
	TAdd<int>(a, ch);
}
```

### 普通函数与函数模板的调用规则
1. 调用规则:
	+ 如果函数模板和普通函数都可以实现，优先调用普通函数
	+ 可以通过空模板参数列表来强制调用函数模板
	+ 函数模板也可以发生重载
	+ 如果函数模板可以产生更好的匹配，优先调用函数模板
```cpp
void MyPrint(int a)
{
	cout << "普通函数" << endl;
}

template <class T>
void MyPrint(T a)
{
	cout << "函数模板" << endl;
}

int main()
{
	int a;
	//空模板参数强制调用函数模板
	MyPrint<>(a);
}
```

## 二、模板的局限性
1. 局限性：模板的通用性并不是万能的
2. 有些特定类型，需要用具体化方式做特殊实现(类)
	+ 重载运算符进行比较
	+ 具体化模板来实现代码
```cpp
template<> bool myCompare(Person& p1, Person& p2)
{
	//函数体
}
```
3. 总结:
	+ 利用具体化的模板，可以解决自定义类型的通用化

## 三、类模板
### 类模板语法
1. 作用：建立一个通用类，类中的成员数据类型可以不具体指定，用一个虚拟的类型来代表
```cpp
template<typename T>
//类实现
```
2. 例子
```cpp
template<class NameType, class AgeType>
class Person
{
public:
	Person(NameType name, AgeType age)
	{
		this->name = name;
		this->age = age;
	}
	NameType name;
	AgeType age;
};

int main()
{
	//要指定类型，没有自动类型推导
	Person<string, int> p1("cxk", 18);
}

```

### 类模板和函数模板的区别
1. 区别
	+ 类模板没有自动推导类型的使用方式
	+ 类模板在模板参数列表中可以有默认参数
```cpp
template<class NameType, class AgeType = int>
//类实现
```

### 类模板中成员函数的创建时机
1. 成员函数的创建时机
	+ 普通类中的成员函数一开始就可以创建
	+ 类模板中的成员函数在调用时才创建
2. 原因：刚开始时无法确定对象的类型，使用时才能确定对象的类型