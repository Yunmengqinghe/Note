## 一、顺序表的定义
1. 顺序表用顺序存储的方式实现线性表的顺序存储。把逻辑上相邻的元素存储在物理位置也相邻的存储单元中，元素之间的关系有储存单元的邻接关系来体现
```c
typedef struct
{
	int num;
	int people;
} Customer;
```

## 二、顺序表的实现(静态分配)
1. 实现
```cpp
const int MaxSize = 10;
typedef struct
{
	ElemType data[MaxSize];
	int length;
} Sqlist;
```

2. 示例
 ![[Pasted image 20230830235642.png]]
```cpp
const int MaxSize = 10;
typedef struct
{
	int data[MaxSize];
	int length;
} Sqlist;

void InitList(SqList& sql)
{
	sql.length = 0;
}
int main()
{
	SqList sql;
	InitList(sql);
	//...
	return 0;
}
```

## 三、顺序表的实现(动态分配)
1. 实现
![[Pasted image 20230831092838.png]]
```c
#define InitSize 10  // 顺序表的初始长度

typedef struct {
    ElemType *data;  // 指示动态分配数组的指针
    int MaxSize;     // 顺序表的最大容量
    int length;      // 顺序表的当前长度
} SeqList;           // 顺序表的类型定义（动态分配方式）

//动态内存申请方式
L.data = (ElemType *) malloc (sizeof(ElemType) * InitSize);
```

2. 示例
```c
#include <stdlib.h>

#define InitSize 19  // 默认的最大长度

typedef struct 
{
    int *data;     // 指示动态分配数组的指针
    int MaxSize;   // 顺序表的最大容量
    int length;    // 顺序表的当前长度
} SeqList;

void InitList(SeqList& L) 
{
	// 用 malloc 函数申请一片连续的存储空间
    L.data = (int *)malloc(InitSize * sizeof(int));
    // 顺序表的当前长度
    L.length = 0;
    // 顺序表的最大容量
    L.MaxSize = InitSize;
}

void IncreaseSize(SeqList& L, int len) 
{
	// 保存旧的数据指针
    int *p = L.data; 
    
    // 重新分配更大的内存空间
    L.data = (int *)malloc((L.MaxSize + len) * sizeof(int));  
    
    // 将数据复制到新区域
    for (int i = 0; i < L.length; i++) 
    {
        L.data[i] = p[i];
    }
    
    // 顺序表最大长度增加 len
    L.MaxSize = L.MaxSize + len;
    // 释放原来的内存空间
    free(p);
}

int main() 
{
    SeqList L;
    InitList(L);
    // 声明一个顺序表
    // 初始化顺序表
    //...往顺序表中随便插入几个元素...
    IncreaseSize(L, 5);
    return 0;
}
```

3. 顺序表的特点：
	+ 随机访问，即可以在 O(1) 时间内找到第 i 个元素
	+ 存储密度高，每个节点只存储数据元素 
	+ 拓展容量不方便（即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高）
	+ 插入、删除操作不方便，需要移动大量元素

4. 访问： `LOC(L) + (i-1)*sizeof(ElemType)`
 ![[Pasted image 20230831093755.png]]
