## 位运算符 
+ & 按位的与
+ | 按位的或
+ ~ 按位取反
+ ^ 按位的异或
+ << 左移
+ >> 右移


## 按位运算
### 按位与 
+ 符号：**&**
+ 运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算），即 0 & 0= 0 ，0 & 1= 0，1 & 0= 0， 1 & 1= 1。
+ 例：3 & 5  即 00000011 & 00000101 = 00000001 ，所以 3 & 5的值为1。
+ 
**应用：**
**1、让某一位或某些位为0：x & 0xFE**
*用FE只保留了下面二进制数的除最后一位数的所有数*
![[6706bc09e702e2ee267718088a9357c.jpg]]


**2、取一个数中的一段： x & 0xFF**
*只保留最后一段二进制数*
![[a9573363288bfcc08e78b2e6d8049e3.jpg]]

### 按位或
+ 符号：**|**
+ 运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。
+ 例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。

**应用：**
**1、使得一位或几个位为1：x | 0x01**
![[49f3f0585a658051343dd92ce83bf9b.jpg]]

**2、把两个数拼起来：0x00FF | 0xFF00**
*00的地方被FF代替，结果是 0xFF*

### 按位取反
+ 符号：~
+ 运算规则：把1位变0，0位变1

### 按位异或
+ 符号：^
+ 运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。即 0 ^ 0=0 ，0 ^ 1= 1 ，1 ^ 0= 1 ，1 ^ 1= 0 
+ 例：2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 
+ 对一个变量用同一个值异或两次，等于什么都没做，x ^ y ^ y -> x


## 移位运算
### 左移运算 
+ 符号：**<<**
+ 运算规则：顾名思义将二进制数整体向左移动，多余的位数进行舍去操作（比如向左移动n位，即将二进制数的前n位舍去），**末尾补0**。
+ 左移一位等于原数乘2，以此类推


### 右移运算
+ 符号：**>>**
+ 右移即将二进制数末尾的n位舍去，对左边的高位进行补位，**右移操作中，正数左边补0，负数左边补1**。
+ 右移一位等于原数除2，以此类推


## 位运算例子
### 输出一个数的二进制
```C
include<stdio.h>
int main()
{
	int number;
	scanf("%d",&number);
	unsigned mask = 1u << 31;
	for(;mask;mask >>= 1)
	{
	    printf("%d",number & mask?1:0);
	}
	printf("\n");
	return 0;
}
//将number二进制数的每一位与1相与，若相与则输出1、不相与则输出0，得到的就是numer的二进制数
```